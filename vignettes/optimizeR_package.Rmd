---
title: "How to use the optimizeR package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{How to use the optimizeR package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

# library(optimizeR)
devtools::load_all() # TODO
```

# Introduction

The `{optimizeR}` package offers an object-oriented solution for numerical optimization in R, addressing the inconsistency in how optimization algorithms are implemented across different R packages. By providing a unified API, `{optimizeR}` streamlines interactions with various optimizers, which traditionally differ in their argument names, function call structures, and output formats. For instance, the `{stats}` package functions `nlm()` and `optim()` have distinct argument names for the objective function and initial parameter vector, with these elements positioned differently in the function call, and their output values, such as the estimated minimum and parameter vector, labeled inconsistently.

Beyond unifying optimizers, the object-oriented framework of `{optimizeR}` offers additional convenience over directly using individual algorithms. With `{optimizeR}`, any optimizer can be employed for both minimization and maximization tasks, functions can be optimized over multiple arguments, and computation time can be measured or limited for prolonged tasks.

The `{optimizeR}` package itself does not introduce new optimizers but instead provides a flexible framework to standardize the usage of existing ones and accommodate future implementations. The key design principle of `{optimizeR}` is flexibility -- ensuring compatibility with nearly any optimization algorithm in R -- while maintaining ease of use.

This vignette introduces the three main objects in `{optimizeR}`: the `Objective` object for defining objective functions, the `Optimizer` object for specifying numerical optimizers, and the `ParameterSpaces` object for transforming parameters across different spaces.

# Objective function

An objective function defines the goal of an optimization problem, representing the mathematical expression that an algorithm seeks to minimize or maximize. In numerical optimization, the algorithm adjusts input variables (parameters) to find the optimal solution, yielding either the minimum (for minimization) or maximum (for maximization) value of the function.

The `Objective` object encapsulates an objective function and is instantiated as follows:

```{r, define Objective demo, eval = FALSE}
objective_function <- Objective$new(f, target, npar, ...)
```

Here, `f` represents the function to be optimized, `target` specifies the `numeric` `vector` arguments over which the function `f` will be optimized (the so-called target arguments), `npar` defines the length of the target arguments, and `...` allows for additional arguments to be passed to `f` that are fixed during the optimization process.

Once the `Objective` object is created, 

- the objective function can be evaluated at a given point `at` using `objective_function$evaluate(at)`,
- a gradient and a Hessian function can be defined and evaluated via `$set_gradient()`, `$set_hessian()`, `$evaluate_gradient(at)`, and `$evaluate_hessian(at)`, respectively (see Example 1 below)
- fixed arguments can be accessed with `$get_argument()`, modified using `$set_argument()`, or removed via `$remove_argument()`,
- the `$validate()` method ensures that the object is properly configure (see Example 2).

The following two examples illustrate how to create and use the `Objective` object.

## Example 1: Himmelblau's function

Here is an implementation of the [Himmelblau's function](https://en.wikipedia.org/wiki/Himmelblau%27s_function) $$f(x, y) = (x^2 + y - 11)^2 + (x + y^2 - 7)^2:$$

```{r, himmelblau definition}
himmelblau <- function(x) (x[1]^2 + x[2] - 11)^2 + (x[1] + x[2]^2 - 7)^2
```

This function has four identical local minima, for example in $x = 3$ and $y = 2$:

```{r, himmelblau evaluate}
himmelblau(c(3, 2))
```

```{r, visualize_himmelblau, echo = FALSE, message = FALSE, warning = FALSE, fig.align = 'center', out.width = "80%", fig.dim = c(8, 6)}
library("ggplot2")
x <- y <- seq(-5, 5, 0.1)
grid <- expand.grid(x, y)
grid$z <- apply(grid, 1, himmelblau)
ggplot(grid, aes(x = Var1, y = Var2, z = z)) +
  geom_raster(aes(fill = z)) +
  geom_contour(colour = "white", bins = 40) +
  scale_fill_gradient(low = "blue", high = "red") +
  theme_linedraw() +
  labs(
    x = "x",
    y = "y",
    fill = "value",
    title = "Himmelblau function",
    subtitle = "the four local minima are marked in green"
  ) +
  coord_fixed() +
  annotate(
    "Text",
    x = c(3, -2.8, -3.78, 3.58),
    y = c(2, 3.13, -3.28, -1.85),
    label = "X", size = 6, color = "green"
  )
```

The `himmelblau(x)` function is a two-dimensional function that accepts a single vector input `x` of length 2, with no additional parameters. To create the corresponding `Objective` object, use the following:^[The `target` argument is not required in this case. If not provided, it will automatically be set to the first argument of `f`.]

```{r, define Objective himmelblau}
himmelblau_objective <- Objective$new(
  f = himmelblau,
  target = "x",
  npar = 2
)

himmelblau_objective$evaluate(c(3, 2))
```

For the Himmelblau's function, it is straightforward to define the analytical gradient and Hessian as follows:

```{r, himmelblau gradient and hessian}
himmelblau_gradient <- function(x) {
  c(
    4 * x[1] * (x[1]^2 + x[2] - 11) + 2 * (x[1] + x[2]^2 - 7),
    2 * (x[1]^2 + x[2] - 11) + 4 * x[2] * (x[1] + x[2]^2 - 7)
  )
}

himmelblau_hessian <- function(x) {
  matrix(
    c(
      12 * x[1]^2 + 4 * x[2] - 42, 4 * x[1] + 4 * x[2],
      4 * x[1] + 4 * x[2], 12 * x[2]^2 + 4 * x[1] - 26
    ),
    nrow = 2
  )
}
```

They can be used for optimization (see below) by including them into the `himmelblau_objective` object:

```{r, gradient and hessian to himmelblau objective}
himmelblau_objective$set_gradient(himmelblau_gradient)
himmelblau_objective$set_hessian(himmelblau_hessian)

himmelblau_objective$evaluate_gradient(c(3, 2))
himmelblau_objective$evaluate_hessian(c(3, 2))
```

## Example 2: Log-likelihood function of two-class Gaussian mixture

Consider fitting a two-class Gaussian mixture model via maximizing the model's log-likelihood function

$$\ell(\mu_1, \mu_2, \sigma_1, \sigma_2, \lambda) = \sum_{i=1}^n \log\Big( \lambda \phi_{\mu_1, \sigma_1^2}(x_i) + (1-\lambda)\phi_{\mu_2,\sigma_2^2} (x_i) \Big),$$

where the sum goes over all observations $1, \dots, n$, $\phi_{\mu_1, \sigma_1^2}$ and $\phi_{\mu_2, \sigma_2^2}$ denote the normal density for the first and second cluster, respectively, and $\lambda$ is the mixing proportion. As there exists no closed-form solution for the maximum likelihood estimator, we need numerical optimization for finding the function optimum. The model is fitted to the following data:^[The `faithful` data set contains information about eruption times (`eruptions`) of the Old Faithful geyser in Yellowstone National Park, Wyoming, USA. The data histogram hints at two clusters with short and long eruption times, respectively. For both clusters, we assume a normal distribution, such that we consider a mixture of two Gaussian densities for modeling the overall eruption times.]

```{r, visualize_faithful, echo = FALSE, message = FALSE, warning = FALSE, fig.align = 'center', out.width = "80%", fig.dim = c(8, 6)}
library("ggplot2")
ggplot(datasets::faithful, aes(x = eruptions)) +
  geom_histogram(aes(y = after_stat(density)), bins = 30) +
  xlab("eruption time (min)")
```

The following function calculates the log-likelihood value given the parameters `mu`, `sd`, and `lambda`, and the observation vector `data`:^[We restrict the standard deviations `sd` to be positive (via the exponential transformation) and `lambda` to be between 0 and 1 (via the logit transformation).]

```{r, normal mixture}
normal_mixture_llk <- function(mu, sd, lambda, data) {
  sd <- exp(sd)
  lambda <- plogis(lambda)
  c1 <- lambda * dnorm(data, mu[1], sd[1])
  c2 <- (1 - lambda) * dnorm(data, mu[2], sd[2])
  sum(log(c1 + c2))
}
```

The corresponding `Objective` object is defined as follows:

```{r, define Objective mixture}
mixture_objective <- Objective$new(
  f = normal_mixture_llk,
  target = c("mu", "sd", "lambda"),
  npar = c(2, 2, 1),
  data = datasets::faithful$eruptions
)

mixture_objective$evaluate(1:5)
```

The `$validate()` method can be used to verify that the `mixture_objective` object has been correctly specified:

```{r, validate Objective mixture}
mixture_objective$validate(1:5, .verbose = FALSE)
```

# Optimizer objects

## Optimizer dictionary

## Example 1 (cont.)

## Example 2 (cont.)

## Custom optimizers

# Parameter spaces


 
